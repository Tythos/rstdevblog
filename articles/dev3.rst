Developing a Development Blog, Part 3
=====================================

Wrapping It Up
~~~~~~~~~~~~~~

.. contents::

Publishing An Article
---------------------

You may recall a "/publish?name=...&token=..." REST-only endpoint we included
in our WSGI application. There are three parameters we need to pass to a
publish request:

* Name of the article, as part of thw query string

* Body of the article (RST-formatted text) as the request Body

* A token that will be used to verify/authenticate the upload.

The token will be generated by an SHA-256 hash of the article name with a
secret salt phrase. If the token is successfully verified, the endpoint writes
a new file to the "articles/" folder:

* The filename will be the article name passed in the query string

* The content of the file will come from the request body

The system will take care of "date created" timestamps, of course. Remaining
meta-data will be compiled as follows:

* The "name" will come from the file name (without extension); this is a unique
  NAME, not a full title (it will not be visible to the user)

* The title comes from analysis of the RST content. The top-level header will
  be extracted to identify the article title.

* The keywords come from first- and second-level headers extracted from the
  RST content. These words are then sorted by frequency, and stripped of
  "stopwords" (common words we reject, like "the" or "an", listed in a special
  "stopwords.txt" file we store on the server)

* The publication date comes from the date-modified timestamp of the file.
  (Python's "os.stat()" function comes in handy here.)

Hosting
-------

Once an "application" WSGI function is contained within the
"wsgi_application.py" module, Passenger will route request handlers through
that function. We also use a "tmp/restart.txt" file that we can "touch" when we
want the server to restart the Passenger host. Once the service is up and
running, though, it should require very little modification; all article
handling is automatic, including metadata; no backend/dashboard is required.

Viewing
-------

Browing to your subdomain should show the default view. Multiple styling
passes may be required as the layout and class identifiers of specific RST
elements may not be obvious at first. However, you'll now be able to cite
explicit article URLs, and you can modify templating to even drop in "share"
links to Twitter, LinkedIn, or other networks. Since so much of the application
is simply static files, modifying and updating things like layout and design is
*SUPER* straightforward.

Conclusion
----------

I'm pretty happy with this arrangement. It gives me all the simplicity I need,
short of something super-streamlined like GitHub sites. Speaking of which, you
can find the source for this project on GitHub:

  https://github.com/Tythos/devblog

There are some performance issues. I think these stem from two main problems:

* Metadata (returned by the "/listings" endpoint) involves multiple file reads
  (one for each RST article), and parsing each one for keyword identification.
  This endpoint is used on nearly every page. We could cache this.

* CherryPy is nice, but not super-high performance. Lately I've been using a
  lot of Flask+GEvent pairings for high-performance web services; since Flask
  can also export WSGI-compliant applications, it would be easy to switch over.

Other future improvements could include an automatically-generated RSS feed
based on publication history. We'll see what priorities end up being.
